[
    {
        "TYPE":"OPERATOR",
        "INVALID":"#",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"#",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"#",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"#",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"#",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"#",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"#",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"#",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR",
        "INVALID":"@",
        "FIRST":"",
        "SECOND":""
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":",",
        "SECOND":"##"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":",",
        "SECOND":"##"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":",",
        "SECOND":"##"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":",",
        "SECOND":"##"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":",",
        "SECOND":"##"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":",",
        "SECOND":"##"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":",",
        "SECOND":"##"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":"(",
        "SECOND":"^"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":"(",
        "SECOND":"^"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":"(",
        "SECOND":"^"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":"(",
        "SECOND":"^"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":"(",
        "SECOND":"^"
    },
    {
        "TYPE":"OPERATOR3",
        "FIRST":"(",
        "SECOND":"^"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":">",
        "SECOND":"#"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":">",
        "SECOND":"#"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":">",
        "SECOND":"#"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":">",
        "SECOND":"#"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":">",
        "SECOND":"#"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":">",
        "SECOND":"#"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":">",
        "SECOND":"#ifndef"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"^",
        "SECOND":")"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"-",
        "SECOND":"@"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"-",
        "SECOND":"@"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"-",
        "SECOND":"@"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"=",
        "SECOND":"sizeof"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"/",
        "SECOND":"sizeof"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"=",
        "SECOND":"@"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"=",
        "SECOND":"@"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"-",
        "SECOND":"#pragma"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"-",
        "SECOND":"#pragma"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"-",
        "SECOND":"#pragma"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"=",
        "SECOND":"sizeof"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"=",
        "SECOND":"sizeof"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"=",
        "SECOND":"sizeof"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"-",
        "SECOND":"#pragma"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"-",
        "SECOND":"@"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"-",
        "SECOND":"#pragma"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"||",
        "SECOND":"#endif"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"?",
        "SECOND":"@"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"^",
        "SECOND":")"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"^",
        "SECOND":")"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"^",
        "SECOND":")"
    },
    {
        "TYPE":"OPERATOR4",
        "FIRST":"^",
        "SECOND":")"
    },
    {
        "TYPE":"OPERAND_4",
        "FIRST":"Object",
        "SECOND":"Stack"
    },
    {
        "TYPE":"OPERAND_4",
        "FIRST":"Stack",
        "SECOND":"management"
    },
    {
        "TYPE":"OPERAND_4",
        "FIRST":"management",
        "SECOND":"functions"
    },
    {
        "TYPE":"OPERAND_4",
        "FIRST":"functions",
        "SECOND":"JK_STATIC_INLINE"
    },
    {
        "TYPE":"OPERAND_4",
        "FIRST":"JK_STATIC_INLINE",
        "SECOND":"ConversionResult"
    },
    {
        "TYPE":"OPERAND_4",
        "FIRST":"JK_STATIC_INLINE",
        "SECOND":"void"
    },
    {
        "TYPE":"OPERAND_4",
        "FIRST":"of",
        "SECOND":"v1"
    },
    {
        "TYPE":"OPERAND_4",
        "FIRST":"v1",
        "SECOND":".4"
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// JSONKit technically has a few problems from a \"strictly C99 conforming\" standpoint, though they are of the pedantic nitpicking variety.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// In practice, though, for the compilers and architectures we can reasonably expect this code to be compiled for, these pedantic nitpicks aren't really a problem.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"#if (UINT_MAX != 0xffffffffU) || (INT_MIN != (-0x7fffffff-1)) || (ULLONG_MAX != 0xffffffffffffffffULL) || (LLONG_MIN != (-0x7fffffffffffffffLL-1LL))",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// Cocoa / Foundation uses NS*Integer as the type for a lot of arguments.  We make sure that NS*Integer is something we are expecting and is reasonably compatible with size_t / ssize_t",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// JK_TOKENBUFFER_SIZE is the default stack size for the temporary buffer used to hold \"non-simple\" strings (i.e., contains \\ escapes)",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// JK_STACK_OBJS is the default number of spaces reserved on the stack for temporarily storing pointers to Obj-C objects before they can be transferred to a NSArray / NSDictionary.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"#define JK_WARN_UNUSED_CONST_NONNULL_ARGS(arg, ...)                JK_ATTRIBUTES(warn_unused_result, const, nonnull(arg, ##__VA_ARGS__))",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"#define JK_WARN_UNUSED_PURE_NONNULL_ARGS(arg, ...)                 JK_ATTRIBUTES(warn_unused_result, pure, nonnull(arg, ##__VA_ARGS__))",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"#define JK_ALLOC_SIZE_NON_NULL_ARGS_WARN_UNUSED(as, nn, ...) JK_ATTRIBUTES(warn_unused_result, nonnull(nn, ##__VA_ARGS__), alloc_size(as))",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"+ (id)serializeObject:(id)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(id)delegate selector:(SEL)selector error:(NSError **)error;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"- (id)serializeObject:(id)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(id)delegate selector:(SEL)selector error:(NSError **)error;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static JKDictionary     *_JKDictionaryCreate(id *keys, NSUInteger *keyHashes, id *objects, NSUInteger count, BOOL mutableCollection);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static id _NSStringObjectFromJSONString(NSString *jsonString, JKParseOptionFlags parseOptionFlags, NSError **error, BOOL mutableCollection);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static void jk_objectStack_setToStackBuffer(JKObjectStack *objectStack, void **objects, void **keys, CFHashCode *cfHashes, size_t count);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static void   jk_error_parse_accept_or3(JKParseState *parseState, int state, NSString *or1String, NSString *or2String, NSString *or3String);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"JK_STATIC_INLINE void jk_set_parsed_token(JKParseState *parseState, const unsigned char *ptr, size_t length, JKTokenType type, size_t advanceBy);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static int jk_encode_printf(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format, ...);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static int jk_encode_write(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static int jk_encode_writen(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format, size_t length);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"JK_STATIC_INLINE void jk_encode_updateCache(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"#define jk_encode_write1(es, dc, f)  (JK_EXPECT_F(_jk_encode_prettyPrint) ? jk_encode_write1slow(es, dc, f) : jk_encode_write1fast(es, dc, f))",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// However, Louis Gerbarg (via cocoa-dev) pointed out that Cocoa / Core Foundation actually implements only a single class that inherits from the",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// mutable version, and keeps an ivar bit for whether or not that instance is mutable.  This means that the immutable versions of the collection",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// classes receive the mutating methods, but this is handled by having those methods throw an exception when the ivar bit is set to immutable.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// Basically, there seem to be a problem with using +load in static libraries on iOS.  However, __attribute__ ((constructor)) does work correctly.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// Since we do not require anything \"special\" that +load provides, and we can accomplish the same thing using __attribute__ ((constructor)), the +load logic was moved here.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // Though technically not required, the run time environment at load time initialization may be less than ideal.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  _jk_NSNumberInitWithUnsignedLongLongImp = (NSNumberInitWithUnsignedLongLongImp)[temp_NSNumber methodForSelector:@selector(initWithUnsignedLongLong:)];",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  [NSException raise:NSInvalidArgumentException format:@\"*** - [%@ %@]: The %@ class is private to JSONKit and should not be used in this fashion.\", NSStringFromClass([self class]), NSStringFromSelector(_cmd), NSStringFromClass([self class])];",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_T((array = (JKArray *)calloc(1UL, _JKArrayInstanceSize)) != NULL)) { // Directly allocate the JKArray instance via calloc.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((array != NULL) && (array->objects != NULL) && (array->count <= array->capacity) && (objectIndex <= array->count) && (newObject != NULL));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(!((array != NULL) && (array->objects != NULL) && (objectIndex <= array->count) && (newObject != NULL))) { [newObject autorelease]; return; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if((newObjects = (id *)realloc(array->objects, sizeof(id) * (array->capacity + 16UL))) == NULL) { [NSException raise:NSMallocException format:@\"Unable to resize objects array.\"]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if((objectIndex + 1UL) < array->count) { memmove(&array->objects[objectIndex + 1UL], &array->objects[objectIndex], sizeof(id) * ((array->count - 1UL) - objectIndex)); array->objects[objectIndex] = NULL; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((array != NULL) && (array->objects != NULL) && (array->count <= array->capacity) && (objectIndex < array->count) && (array->objects[objectIndex] != NULL) && (newObject != NULL));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(!((array != NULL) && (array->objects != NULL) && (objectIndex < array->count) && (array->objects[objectIndex] != NULL) && (newObject != NULL))) { [newObject autorelease]; return; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((array != NULL) && (array->objects != NULL) && (array->count > 0UL) && (array->count <= array->capacity) && (objectIndex < array->count) && (array->objects[objectIndex] != NULL));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(!((array != NULL) && (array->objects != NULL) && (array->count > 0UL) && (array->count <= array->capacity) && (objectIndex < array->count) && (array->objects[objectIndex] != NULL))) { return; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if((objectIndex + 1UL) < array->count) { memmove(&array->objects[objectIndex], &array->objects[objectIndex + 1UL], sizeof(id) * ((array->count - 1UL) - objectIndex)); array->objects[array->count - 1UL] = NULL; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    for(atObject = 0UL; atObject < count; atObject++) { if(JK_EXPECT_T(objects[atObject] != NULL)) { CFRelease(objects[atObject]); objects[atObject] = NULL; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if((objectsPtr     == NULL)  && (NSMaxRange(range) > 0UL))   { [NSException raise:NSRangeException format:@\"*** -[%@ %@]: pointer to objects array is NULL but range length is %lu\", NSStringFromClass([self class]), NSStringFromSelector(_cmd), (unsigned long)NSMaxRange(range)];        }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if((range.location >  count) || (NSMaxRange(range) > count)) { [NSException raise:NSRangeException format:@\"*** -[%@ %@]: index (%lu) beyond bounds (%lu)\",                          NSStringFromClass([self class]), NSStringFromSelector(_cmd), (unsigned long)NSMaxRange(range), (unsigned long)count]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(objectIndex >= count) { [NSException raise:NSRangeException format:@\"*** -[%@ %@]: index (%lu) beyond bounds (%lu)\", NSStringFromClass([self class]), NSStringFromSelector(_cmd), (unsigned long)objectIndex, (unsigned long)count]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  while(JK_EXPECT_T(enumeratedCount < len) && JK_EXPECT_T(state->state < count)) { NSParameterAssert(objects[state->state] != NULL); stackbuf[enumeratedCount++] = objects[state->state++]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(mutations   == 0UL)   { [NSException raise:NSInternalInconsistencyException format:@\"*** -[%@ %@]: mutating method sent to immutable object\", NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(anObject    == NULL)  { [NSException raise:NSInvalidArgumentException       format:@\"*** -[%@ %@]: attempt to insert nil\",                    NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(objectIndex >  count) { [NSException raise:NSRangeException                 format:@\"*** -[%@ %@]: index (%lu) beyond bounds (%lu)\",          NSStringFromClass([self class]), NSStringFromSelector(_cmd), (unsigned long)objectIndex, (unsigned long)(count + 1UL)]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(mutations   == 0UL)   { [NSException raise:NSInternalInconsistencyException format:@\"*** -[%@ %@]: mutating method sent to immutable object\", NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(objectIndex >= count) { [NSException raise:NSRangeException                 format:@\"*** -[%@ %@]: index (%lu) beyond bounds (%lu)\",          NSStringFromClass([self class]), NSStringFromSelector(_cmd), (unsigned long)objectIndex, (unsigned long)count]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(mutations   == 0UL)   { [NSException raise:NSInternalInconsistencyException format:@\"*** -[%@ %@]: mutating method sent to immutable object\", NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(anObject    == NULL)  { [NSException raise:NSInvalidArgumentException       format:@\"*** -[%@ %@]: attempt to insert nil\",                    NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(objectIndex >= count) { [NSException raise:NSRangeException                 format:@\"*** -[%@ %@]: index (%lu) beyond bounds (%lu)\",          NSStringFromClass([self class]), NSStringFromSelector(_cmd), (unsigned long)objectIndex, (unsigned long)count]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  [NSException raise:NSInvalidArgumentException format:@\"*** - [%@ %@]: The %@ class is private to JSONKit and should not be used in this fashion.\", NSStringFromClass([self class]), NSStringFromSelector(_cmd), NSStringFromClass([self class])];",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// These values are taken from Core Foundation CF-550 CFBasicHash.m.  As a bonus, they align very well with our JKHashTableEntry struct too.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSUInteger bottom = 0UL, top = sizeof(jk_dictionaryCapacities) / sizeof(NSUInteger), mid = 0UL, tableSize = (NSUInteger)lround(floor(((double)count) * 1.33));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  while(top > bottom) { mid = (top + bottom) / 2UL; if(jk_dictionaryCapacities[mid] < tableSize) { bottom = mid + 1UL; } else { top = mid; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F((dictionary->entry = (JKHashTableEntry *)calloc(1UL, sizeof(JKHashTableEntry) * capacityForCount)) == NULL)) { [NSException raise:NSMallocException format:@\"Unable to allocate memory for hash table.\"]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    for(idx = 0UL; idx < oldCapacity; idx++) { if(oldEntry[idx].key != NULL) { _JKDictionaryAddObject(dictionary, oldEntry[idx].keyHash, oldEntry[idx].key, oldEntry[idx].object); oldEntry[idx].keyHash = 0UL; oldEntry[idx].key = NULL; oldEntry[idx].object = NULL; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((keys != NULL) && (keyHashes != NULL) && (objects != NULL) && (_JKDictionaryClass != NULL) && (_JKDictionaryInstanceSize > 0UL));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_T((dictionary = (JKDictionary *)calloc(1UL, _JKDictionaryInstanceSize)) != NULL)) { // Directly allocate the JKDictionary instance via calloc.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F((dictionary->entry = (JKHashTableEntry *)calloc(1UL, sizeof(JKHashTableEntry) * dictionary->capacity)) == NULL)) { [dictionary autorelease]; return(NULL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((dictionary != NULL) && (entry != NULL) && (entry->key != NULL) && (entry->object != NULL) && (dictionary->count > 0UL) && (dictionary->count <= dictionary->capacity));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  // In order for certain invariants that are used to speed up the search for a particular key, we need to \"re-add\" all the entries in the hash table following this entry until we hit a NULL entry.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if(JK_EXPECT_T(atAddEntry->key == NULL)) { NSCParameterAssert((atAddEntry->keyHash == 0UL) && (atAddEntry->object == NULL)); atAddEntry->key = key; atAddEntry->object = object; atAddEntry->keyHash = keyHash; break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((dictionary != NULL) && (key != NULL) && (object != NULL) && (dictionary->count < dictionary->capacity) && (dictionary->entry != NULL));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F(atEntry->keyHash == keyHash) && JK_EXPECT_T(atEntry->key != NULL) && (JK_EXPECT_F(key == atEntry->key) || JK_EXPECT_F(CFEqual(atEntry->key, key)))) { _JKDictionaryRemoveObjectWithEntry(dictionary, atEntry); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_T(atEntry->key == NULL)) { NSCParameterAssert((atEntry->keyHash == 0UL) && (atEntry->object == NULL)); atEntry->key = key; atEntry->object = object; atEntry->keyHash = keyHash; dictionary->count++; return; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_T(atEntry->keyHash == keyHash) && JK_EXPECT_T(atEntry->key != NULL) && ((atEntry->key == aKey) || CFEqual(atEntry->key, aKey))) { NSCParameterAssert(atEntry->object != NULL); return(atEntry); break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F(atEntry->key == NULL)) { NSCParameterAssert(atEntry->object == NULL); return(NULL); break; } // If the key was in the table, we would have found it by now.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  while(JK_EXPECT_T(enumeratedCount < len) && JK_EXPECT_T(state->state < capacity)) { if(JK_EXPECT_T(entry[state->state].key != NULL)) { stackbuf[enumeratedCount++] = entry[state->state].key; } state->state++; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(mutations == 0UL)  { [NSException raise:NSInternalInconsistencyException format:@\"*** -[%@ %@]: mutating method sent to immutable object\", NSStringFromClass([self class]), NSStringFromSelector(_cmd)];       }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(aKey      == NULL) { [NSException raise:NSInvalidArgumentException       format:@\"*** -[%@ %@]: attempt to insert nil key\",                NSStringFromClass([self class]), NSStringFromSelector(_cmd)];       }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(anObject  == NULL) { [NSException raise:NSInvalidArgumentException       format:@\"*** -[%@ %@]: attempt to insert nil value (key: %@)\",    NSStringFromClass([self class]), NSStringFromSelector(_cmd), aKey]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(mutations == 0UL)  { [NSException raise:NSInternalInconsistencyException format:@\"*** -[%@ %@]: mutating method sent to immutable object\", NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(aKey      == NULL) { [NSException raise:NSInvalidArgumentException       format:@\"*** -[%@ %@]: attempt to remove nil key\",                NSStringFromClass([self class]), NSStringFromSelector(_cmd)]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"JK_STATIC_INLINE JKHash jk_calculateHash(JKHash currentHash, unsigned char c) { return((((currentHash << 5) + currentHash) + (c - 29)) ^ (currentHash >> 19)); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  for(atCharacterPtr = lineStart; atCharacterPtr < JK_END_STRING_PTR(parseState); atCharacterPtr++) { lineEnd = atCharacterPtr; if(jk_parse_is_newline(parseState, atCharacterPtr)) { break; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    lineString   = [[[NSString alloc] initWithBytes:lineStart length:(lineEnd - lineStart) encoding:NSUTF8StringEncoding] autorelease];",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    carretString = [NSString stringWithFormat:@\"%*.*s^\", (int)(parseState->atIndex - parseState->lineStartIndex), (int)(parseState->atIndex - parseState->lineStartIndex), \" \"];",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                                                                              formatString,                                             NSLocalizedDescriptionKey,",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                                                                              [NSNumber numberWithUnsignedLong:parseState->atIndex],    @\"JKAtIndexKey\",",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                                                                              [NSNumber numberWithUnsignedLong:parseState->lineNumber], @\"JKLineNumberKey\",",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(managedBuffer->roundSizeUpToMultipleOf > 0UL) { roundedUpNewSize = newSize + ((managedBuffer->roundSizeUpToMultipleOf - (newSize % managedBuffer->roundSizeUpToMultipleOf)) % managedBuffer->roundSizeUpToMultipleOf); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      managedBuffer->flags        = (managedBuffer->flags & ~JKManagedBufferLocationMask) | (JKManagedBufferOnHeap | JKManagedBufferMustFree);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      NSCParameterAssert(((managedBuffer->flags & JKManagedBufferMustFree) != 0) && ((managedBuffer->flags & JKManagedBufferLocationMask) == JKManagedBufferOnHeap));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if((managedBuffer->bytes.ptr = (unsigned char *)reallocf(managedBuffer->bytes.ptr, roundedUpNewSize)) == NULL) { return(NULL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static void jk_objectStack_setToStackBuffer(JKObjectStack *objectStack, void **objects, void **keys, CFHashCode *cfHashes, size_t count) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  for(idx = 0UL; idx < objectStack->count; idx++) { objectStack->objects[idx] = NULL; objectStack->keys[idx] = NULL; objectStack->cfHashes[idx] = 0UL; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(objectStack->roundSizeUpToMultipleOf > 0UL) { roundedUpNewCount = newCount + ((objectStack->roundSizeUpToMultipleOf - (newCount % objectStack->roundSizeUpToMultipleOf)) % objectStack->roundSizeUpToMultipleOf); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if((newObjects  = (void **     )calloc(1UL, roundedUpNewCount * sizeof(void *    ))) == NULL) { returnCode = 1; goto errorExit; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if((newKeys     = (void **     )calloc(1UL, roundedUpNewCount * sizeof(void *    ))) == NULL) { returnCode = 1; goto errorExit; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if((newCFHashes = (CFHashCode *)calloc(1UL, roundedUpNewCount * sizeof(CFHashCode))) == NULL) { returnCode = 1; goto errorExit; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      NSCParameterAssert(((objectStack->flags & JKObjectStackMustFree) != 0) && ((objectStack->flags & JKObjectStackLocationMask) == JKObjectStackOnHeap));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if((newObjects  = (void  **    )realloc(objectStack->objects,  roundedUpNewCount * sizeof(void *    ))) != NULL) { objectStack->objects  = newObjects;  newObjects  = NULL; } else { returnCode = 1; goto errorExit; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if((newKeys     = (void  **    )realloc(objectStack->keys,     roundedUpNewCount * sizeof(void *    ))) != NULL) { objectStack->keys     = newKeys;     newKeys     = NULL; } else { returnCode = 1; goto errorExit; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if((newCFHashes = (CFHashCode *)realloc(objectStack->cfHashes, roundedUpNewCount * sizeof(CFHashCode))) != NULL) { objectStack->cfHashes = newCFHashes; newCFHashes = NULL; } else { returnCode = 1; goto errorExit; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      for(idx = objectStack->count; idx < roundedUpNewCount; idx++) { objectStack->objects[idx] = NULL; objectStack->keys[idx] = NULL; objectStack->cfHashes[idx] = 0UL; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F(ch >= UNI_SUR_HIGH_START) && (JK_EXPECT_T(ch <= UNI_SUR_LOW_END)))                                                        { result = sourceIllegal; ch = UNI_REPLACEMENT_CHAR; goto finished; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F(ch >= 0xFDD0U) && (JK_EXPECT_F(ch <= 0xFDEFU) || JK_EXPECT_F((ch & 0xFFFEU) == 0xFFFEU)) && JK_EXPECT_T(ch <= 0x10FFFFU)) { result = sourceIllegal; ch = UNI_REPLACEMENT_CHAR; goto finished; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F(ch == 0U))                                                                                                                { result = sourceIllegal; ch = UNI_REPLACEMENT_CHAR; goto finished; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static ConversionResult ConvertSingleCodePointInUTF8(const UTF8 *sourceStart, const UTF8 *sourceEnd, UTF8 const **nextUTF8, UTF32 *convertedUTF32) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    result = ((source < sourceEnd) && (((*source) & 0xc0) != 0x80)) ? sourceIllegal : ((sourceStart + extraBytesToRead + 1) > sourceEnd) ? sourceExhausted : sourceIllegal;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"JK_STATIC_INLINE int jk_string_add_unicodeCodePoint(JKParseState *parseState, uint32_t unicodeCodePoint, size_t *tokenBufferIdx, JKHash *stringHash) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if((result = ConvertUTF32toUTF8(unicodeCodePoint, &u8s, (parseState->token.tokenBuffer.bytes.ptr + parseState->token.tokenBuffer.bytes.length))) != conversionOK) { if(result == targetExhausted) { return(1); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  while(*tokenBufferIdx < nextIdx) { *stringHash = jk_calculateHash(*stringHash, parseState->token.tokenBuffer.bytes.ptr[(*tokenBufferIdx)++]); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F(atStringCharacter == endOfBuffer)) { /* XXX Add error message */ stringState = JSONStringStateError; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if(JK_EXPECT_F((result = ConvertSingleCodePointInUTF8(atStringCharacter - 1, endOfBuffer, (UTF8 const **)&nextValidCharacter, &u32ch)) != conversionOK)) { goto switchToSlowPath; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      while(atStringCharacter < nextValidCharacter) { NSCParameterAssert(JK_AT_STRING_PTR(parseState) <= JK_END_STRING_PTR(parseState)); stringHash = jk_calculateHash(stringHash, *atStringCharacter++); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        if(JK_EXPECT_F((tokenBufferIdx + 16UL) > parseState->token.tokenBuffer.bytes.length)) { if((tokenBuffer = jk_managedBuffer_resize(&parseState->token.tokenBuffer, tokenBufferIdx + 1024UL)) == NULL) { jk_error(parseState, @\"Internal error: Unable to resize temporary buffer. %@ line #%ld\", [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if(JK_EXPECT_F(currentChar < 0x20UL)) { jk_error(parseState, @\"Invalid character < 0x20 found in string: 0x%2.2x.\", currentChar); stringState = JSONStringStateError; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  for(atStringCharacter = (stringStart + ((atStringCharacter - stringStart) - 1L)); (atStringCharacter < endOfBuffer) && (tokenBufferIdx < parseState->token.tokenBuffer.bytes.length); atStringCharacter++) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if((tokenBufferIdx + 16UL) > parseState->token.tokenBuffer.bytes.length) { if((tokenBuffer = jk_managedBuffer_resize(&parseState->token.tokenBuffer, tokenBufferIdx + 1024UL)) == NULL) { jk_error(parseState, @\"Internal error: Unable to resize temporary buffer. %@ line #%ld\", [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_F(currentChar == (unsigned long)'\"'))  { stringState = JSONStringStateFinished; atStringCharacter++; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_F((result = ConvertSingleCodePointInUTF8(atStringCharacter, endOfBuffer, (UTF8 const **)&nextValidCharacter, &u32ch)) != conversionOK)) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if((result == sourceIllegal) && ((parseState->parseOptionFlags & JKParseOptionLooseUnicode) == 0)) { jk_error(parseState, @\"Illegal UTF8 sequence found in \\\"\\\" string.\");              stringState = JSONStringStateError; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(result == sourceExhausted)                                                                      { jk_error(parseState, @\"End of buffer reached while parsing UTF8 in \\\"\\\" string.\"); stringState = JSONStringStateError; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(jk_string_add_unicodeCodePoint(parseState, u32ch, &tokenBufferIdx, &stringHash))                { jk_error(parseState, @\"Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld\", [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            while(atStringCharacter < nextValidCharacter) { tokenBuffer[tokenBufferIdx++] = *atStringCharacter; stringHash = jk_calculateHash(stringHash, *atStringCharacter++); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        jk_error(parseState, @\"Invalid character < 0x20 found in string: 0x%2.2x.\", currentChar); stringState = JSONStringStateError; goto finishedParsing;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            case 'u': escapedUnicode1 = 0U; escapedUnicode2 = 0U; escapedUnicodeCodePoint = 0U; stringState = JSONStringStateEscapedUnicode1; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            default: jk_error(parseState, @\"Invalid escape sequence found in \\\"\\\" string.\"); stringState = JSONStringStateError; goto finishedParsing; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"              if(!isSurrogate) { escapedUnicode1 = (escapedUnicode1 << 4) | hexValue; } else { escapedUnicode2 = (escapedUnicode2 << 4) | hexValue; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                  if((escapedUnicode1 >= 0xD800U) && (escapedUnicode1 < 0xDC00U)) { stringState = JSONStringStateEscapedNeedEscapeForSurrogate; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                    if((parseState->parseOptionFlags & JKParseOptionLooseUnicode)) { escapedUnicodeCodePoint = UNI_REPLACEMENT_CHAR; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                    else { jk_error(parseState, @\"Illegal \\\\u Unicode escape sequence.\"); stringState = JSONStringStateError; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                  else { jk_error(parseState, @\"Illegal \\\\u Unicode escape sequence.\"); stringState = JSONStringStateError; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                if((isValidCodePoint(&escapedUnicodeCodePoint) == sourceIllegal) && ((parseState->parseOptionFlags & JKParseOptionLooseUnicode) == 0)) { jk_error(parseState, @\"Illegal \\\\u Unicode escape sequence.\"); stringState = JSONStringStateError; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                if(jk_string_add_unicodeCodePoint(parseState, escapedUnicodeCodePoint, &tokenBufferIdx, &stringHash)) { jk_error(parseState, @\"Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld\", [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"              else if((stringState >= JSONStringStateEscapedUnicode1) && (stringState <= JSONStringStateEscapedUnicodeSurrogate4)) { stringState++; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"              default: jk_error(parseState, @\"Unexpected character found in \\\\u Unicode escape sequence.  Found '%c', expected [0-9a-fA-F].\", currentChar); stringState = JSONStringStateError; goto finishedParsing; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if((parseState->parseOptionFlags & JKParseOptionLooseUnicode) == 0) { jk_error(parseState, @\"Required a second \\\\u Unicode escape sequence following a surrogate \\\\u Unicode escape sequence.\"); stringState = JSONStringStateError; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            else { stringState = JSONStringStateParsing; atStringCharacter--;    if(jk_string_add_unicodeCodePoint(parseState, UNI_REPLACEMENT_CHAR, &tokenBufferIdx, &stringHash)) { jk_error(parseState, @\"Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld\", [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if((parseState->parseOptionFlags & JKParseOptionLooseUnicode) == 0) { jk_error(parseState, @\"Required a second \\\\u Unicode escape sequence following a surrogate \\\\u Unicode escape sequence.\"); stringState = JSONStringStateError; goto finishedParsing; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            else { stringState = JSONStringStateParsing; atStringCharacter -= 2; if(jk_string_add_unicodeCodePoint(parseState, UNI_REPLACEMENT_CHAR, &tokenBufferIdx, &stringHash)) { jk_error(parseState, @\"Internal error: Unable to add UTF8 sequence to internal string buffer. %@ line #%ld\", [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        default: jk_error(parseState, @\"Internal error: Unknown stringState. %@ line #%ld\", [NSString stringWithUTF8String:__FILE__], (long)__LINE__); stringState = JSONStringStateError; goto finishedParsing; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      NSCParameterAssert(((parseState->token.tokenPtrRange.ptr + 1) < endOfBuffer) && (parseState->token.tokenPtrRange.length >= 2UL) && (((parseState->token.tokenPtrRange.ptr + 1) + (parseState->token.tokenPtrRange.length - 2)) < endOfBuffer));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  for(atNumberCharacter = numberStart; (JK_EXPECT_T(atNumberCharacter < endOfBuffer)) && (JK_EXPECT_T(!(JK_EXPECT_F(numberState == JSONNumberStateFinished) || JK_EXPECT_F(numberState == JSONNumberStateError)))); atNumberCharacter++) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      case JSONNumberStateWholeNumberStart: if   (currentChar == '-')                                                                              { numberState = JSONNumberStateWholeNumberMinus;      isNegative      = 1; break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      case JSONNumberStateWholeNumberMinus: if   (currentChar == '0')                                                                              { numberState = JSONNumberStateWholeNumberZero;                            break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                                       else if(  (currentChar >= '1') && (currentChar <= '9'))                                                     { numberState = JSONNumberStateWholeNumber;                                break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                                       else                                                     { /* XXX Add error message */                        numberState = JSONNumberStateError;                                      break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      case JSONNumberStateExponentStart:    if(  (currentChar == '+') || (currentChar == '-'))                                                     { numberState = JSONNumberStateExponentPlusMinus;                          break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      case JSONNumberStateExponentPlusMinus:if(!((currentChar >= '0') && (currentChar <= '9'))) { /* XXX Add error message */                        numberState = JSONNumberStateError;                                      break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                                       else {                                              if(numberState == JSONNumberStateFractionalNumberStart) { numberState = JSONNumberStateFractionalNumber; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                                                                                           else                                                    { numberState = JSONNumberStateExponent;         }                         break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      case JSONNumberStateWholeNumber:      if   (currentChar == '.')                                                                              { numberState = JSONNumberStateFractionalNumberStart; isFloatingPoint = 1; break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      case JSONNumberStateFractionalNumber: if   (lowerCaseCC == 'e')                                                                              { numberState = JSONNumberStateExponentStart;         isFloatingPoint = 1; break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      case JSONNumberStateExponent:         if(!((currentChar >= '0') && (currentChar <= '9')) || (numberState == JSONNumberStateWholeNumberZero)) { numberState = JSONNumberStateFinished;              backup          = 1; break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      default:                                                                                    /* XXX Add error message */                        numberState = JSONNumberStateError;                                      break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  parseState->atIndex                    = (parseState->token.tokenPtrRange.ptr + parseState->token.tokenPtrRange.length) - parseState->stringBuffer.bytes.ptr;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F(parseState->token.tokenPtrRange.length == 2UL) && JK_EXPECT_F(numberTempBuf[1] == '0') && JK_EXPECT_F(isNegative)) { isFloatingPoint = 1; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      parseState->token.value.number.doubleValue = strtod((const char *)numberTempBuf, (char **)&endOfNumber); // strtod is documented to return U+2261 (identical to) 0.0 on an underflow error (along with setting errno to ERANGE).",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        parseState->token.value.hash                 = (JK_HASH_INIT + parseState->token.value.type) + (JKHash)parseState->token.value.number.longLongValue;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        parseState->token.value.ptrRange.ptr                 = (const unsigned char *)&parseState->token.value.number.unsignedLongLongValue;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        parseState->token.value.hash                         = (JK_HASH_INIT + parseState->token.value.type) + (JKHash)parseState->token.value.number.unsignedLongLongValue;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          case JKValueTypeDouble:           jk_error(parseState, @\"The value '%s' could not be represented as a 'double' due to %s.\",           numberTempBuf, (parseState->token.value.number.doubleValue == 0.0) ? \"underflow\" : \"overflow\"); break; // see above for == 0.0.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          case JKValueTypeLongLong:         jk_error(parseState, @\"The value '%s' exceeded the minimum value that could be represented: %lld.\", numberTempBuf, parseState->token.value.number.longLongValue);                                   break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          case JKValueTypeUnsignedLongLong: jk_error(parseState, @\"The value '%s' exceeded the maximum value that could be represented: %llu.\", numberTempBuf, parseState->token.value.number.unsignedLongLongValue);                           break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          default:                          jk_error(parseState, @\"Internal error: Unknown token value type. %@ line #%ld\",                     [NSString stringWithUTF8String:__FILE__], (long)__LINE__);                                      break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F(endOfNumber != &numberTempBuf[parseState->token.tokenPtrRange.length]) && JK_EXPECT_F(numberState != JSONNumberStateError)) { numberState = JSONNumberStateError; jk_error(parseState, @\"The conversion function did not consume all of the number tokens characters.\"); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    for(hashIndex = 0UL; hashIndex < parseState->token.value.ptrRange.length; hashIndex++) { parseState->token.value.hash = jk_calculateHash(parseState->token.value.hash, parseState->token.value.ptrRange.ptr[hashIndex]); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"JK_STATIC_INLINE void jk_set_parsed_token(JKParseState *parseState, const unsigned char *ptr, size_t length, JKTokenType type, size_t advanceBy) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((parseState != NULL) && (atCharacterPtr != NULL) && (atCharacterPtr >= parseState->stringBuffer.bytes.ptr) && (atCharacterPtr < JK_END_STRING_PTR(parseState)));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F((*(atCharacterPtr + 0)) == '\\r')) { if((JK_EXPECT_T((atCharacterPtr + 1) < endOfStringPtr)) && ((*(atCharacterPtr + 1)) == '\\n')) { return(2UL); } return(1UL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if((JK_EXPECT_F((*(atCharacterPtr + 0)) == 0xc2)) && (((atCharacterPtr + 1) < endOfStringPtr) && ((*(atCharacterPtr + 1)) == 0x85))) { return(2UL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if((JK_EXPECT_F((*(atCharacterPtr + 0)) == 0xe2)) && (((atCharacterPtr + 2) < endOfStringPtr) && ((*(atCharacterPtr + 1)) == 0x80) && (((*(atCharacterPtr + 2)) == 0xa8) || ((*(atCharacterPtr + 2)) == 0xa9)))) { return(3UL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F((newlineAdvanceAtIndex = jk_parse_is_newline(parseState, JK_AT_STRING_PTR(parseState))) > 0UL)) { parseState->lineNumber++; parseState->atIndex += (newlineAdvanceAtIndex - 1UL); parseState->lineStartIndex = parseState->atIndex + 1UL; return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  for(atCharacterPtr = JK_AT_STRING_PTR(parseState); (JK_EXPECT_T((atCharacterPtr = JK_AT_STRING_PTR(parseState)) < endOfStringPtr)); parseState->atIndex++) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          for(atCharacterPtr = JK_AT_STRING_PTR(parseState); (JK_EXPECT_T((atCharacterPtr = JK_AT_STRING_PTR(parseState)) < endOfStringPtr)); parseState->atIndex++) { if(jk_parse_skip_newline(parseState)) { break; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          for(atCharacterPtr = JK_AT_STRING_PTR(parseState); (JK_EXPECT_T((atCharacterPtr = JK_AT_STRING_PTR(parseState)) < endOfStringPtr)); parseState->atIndex++) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(((*(atCharacterPtr + 0)) == '*') && (((atCharacterPtr + 1) < endOfStringPtr) && ((*(atCharacterPtr + 1)) == '/'))) { parseState->atIndex++; break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"         if(JK_EXPECT_T(currentCharacter == '\"')) { if(JK_EXPECT_T((stopParsing = jk_parse_string(parseState)) == 0)) { jk_set_parsed_token(parseState, parseState->token.tokenPtrRange.ptr, parseState->token.tokenPtrRange.length, JKTokenTypeString, 0UL); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T(currentCharacter == ':')) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeSeparator,   1UL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T(currentCharacter == ',')) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeComma,       1UL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if((JK_EXPECT_T(currentCharacter >= '0') && JK_EXPECT_T(currentCharacter <= '9')) || JK_EXPECT_T(currentCharacter == '-')) { if(JK_EXPECT_T((stopParsing = jk_parse_number(parseState)) == 0)) { jk_set_parsed_token(parseState, parseState->token.tokenPtrRange.ptr, parseState->token.tokenPtrRange.length, JKTokenTypeNumber, 0UL); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T(currentCharacter == '{')) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeObjectBegin, 1UL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T(currentCharacter == '}')) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeObjectEnd,   1UL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T(currentCharacter == '[')) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeArrayBegin,  1UL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T(currentCharacter == ']')) { jk_set_parsed_token(parseState, atCharacterPtr, 1UL, JKTokenTypeArrayEnd,    1UL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T(currentCharacter == 't')) { if(!((JK_EXPECT_T((atCharacterPtr + 4UL) < endOfStringPtr)) && (JK_EXPECT_T(atCharacterPtr[1] == 'r')) && (JK_EXPECT_T(atCharacterPtr[2] == 'u')) && (JK_EXPECT_T(atCharacterPtr[3] == 'e'))))                                            { stopParsing = 1; /* XXX Add error message */ } else { jk_set_parsed_token(parseState, atCharacterPtr, 4UL, JKTokenTypeTrue,  4UL); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T(currentCharacter == 'f')) { if(!((JK_EXPECT_T((atCharacterPtr + 5UL) < endOfStringPtr)) && (JK_EXPECT_T(atCharacterPtr[1] == 'a')) && (JK_EXPECT_T(atCharacterPtr[2] == 'l')) && (JK_EXPECT_T(atCharacterPtr[3] == 's')) && (JK_EXPECT_T(atCharacterPtr[4] == 'e')))) { stopParsing = 1; /* XXX Add error message */ } else { jk_set_parsed_token(parseState, atCharacterPtr, 5UL, JKTokenTypeFalse, 5UL); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T(currentCharacter == 'n')) { if(!((JK_EXPECT_T((atCharacterPtr + 4UL) < endOfStringPtr)) && (JK_EXPECT_T(atCharacterPtr[1] == 'u')) && (JK_EXPECT_T(atCharacterPtr[2] == 'l')) && (JK_EXPECT_T(atCharacterPtr[3] == 'l'))))                                            { stopParsing = 1; /* XXX Add error message */ } else { jk_set_parsed_token(parseState, atCharacterPtr, 4UL, JKTokenTypeNull,  4UL); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F(stopParsing)) { jk_error(parseState, @\"Unexpected token, wanted '{', '}', '[', ']', ',', ':', 'true', 'false', 'null', '\\\"STRING\\\"', 'NUMBER'.\"); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static void jk_error_parse_accept_or3(JKParseState *parseState, int state, NSString *or1String, NSString *or2String, NSString *or3String) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"       if(acceptIdx == 1) { jk_error(parseState, @\"Expected %@, not '%*.*s'\",           acceptStrings[0],                                     (int)parseState->token.tokenPtrRange.length, (int)parseState->token.tokenPtrRange.length, parseState->token.tokenPtrRange.ptr); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  else if(acceptIdx == 2) { jk_error(parseState, @\"Expected %@ or %@, not '%*.*s'\",     acceptStrings[0], acceptStrings[1],                   (int)parseState->token.tokenPtrRange.length, (int)parseState->token.tokenPtrRange.length, parseState->token.tokenPtrRange.ptr); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  else if(acceptIdx == 3) { jk_error(parseState, @\"Expected %@, %@, or %@, not '%*.*s\", acceptStrings[0], acceptStrings[1], acceptStrings[2], (int)parseState->token.tokenPtrRange.length, (int)parseState->token.tokenPtrRange.length, parseState->token.tokenPtrRange.ptr); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  while(JK_EXPECT_T((JK_EXPECT_T(stopParsing == 0)) && (JK_EXPECT_T(parseState->atIndex < parseState->stringBuffer.bytes.length)))) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F(parseState->objectStack.index > (parseState->objectStack.count - 4UL))) { if(jk_objectStack_resize(&parseState->objectStack, parseState->objectStack.count + 128UL)) { jk_error(parseState, @\"Internal error: [array] objectsIndex > %zu, resize failed? %@ line %#ld\", (parseState->objectStack.count - 4UL), [NSString stringWithUTF8String:__FILE__], (long)__LINE__); break; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_F((arrayState & JKParseAcceptValue)          == 0))    { parseState->errorIsPrev = 1; jk_error(parseState, @\"Unexpected value.\");              stopParsing = 1; break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_F((object = jk_object_for_token(parseState)) == NULL)) {                              jk_error(parseState, @\"Internal error: Object == NULL\"); stopParsing = 1; break; } else { parseState->objectStack.objects[parseState->objectStack.index++] = object; arrayState = JKParseAcceptCommaOrEnd; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        case JKTokenTypeArrayEnd: if(JK_EXPECT_T(arrayState & JKParseAcceptEnd)) { NSCParameterAssert(parseState->objectStack.index >= startingObjectIndex); parsedArray = (void *)_JKArrayCreate((id *)&parseState->objectStack.objects[startingObjectIndex], (parseState->objectStack.index - startingObjectIndex), parseState->mutableCollections); } else { parseState->errorIsPrev = 1; jk_error(parseState, @\"Unexpected ']'.\"); } stopParsing = 1; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        case JKTokenTypeComma:    if(JK_EXPECT_T(arrayState & JKParseAcceptComma)) { arrayState = JKParseAcceptValue; } else { parseState->errorIsPrev = 1; jk_error(parseState, @\"Unexpected ','.\"); stopParsing = 1; } break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        default: parseState->errorIsPrev = 1; jk_error_parse_accept_or3(parseState, arrayState, @\"a value\", @\"a comma\", @\"a ']'\"); stopParsing = 1; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F(parsedArray == NULL)) { size_t idx = 0UL; for(idx = startingObjectIndex; idx < parseState->objectStack.index; idx++) { if(parseState->objectStack.objects[idx] != NULL) { CFRelease(parseState->objectStack.objects[idx]); parseState->objectStack.objects[idx] = NULL; } } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  else { size_t idx = 0UL; for(idx = startingObjectIndex; idx < parseState->objectStack.index; idx++) { parseState->objectStack.objects[idx] = NULL; parseState->objectStack.keys[idx] = NULL; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  parsedDictionary = _JKDictionaryCreate((id *)&parseState->objectStack.keys[startingObjectIndex], (NSUInteger *)&parseState->objectStack.cfHashes[startingObjectIndex], (id *)&parseState->objectStack.objects[startingObjectIndex], (parseState->objectStack.index - startingObjectIndex), parseState->mutableCollections);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  while(JK_EXPECT_T((JK_EXPECT_T(stopParsing == 0)) && (JK_EXPECT_T(parseState->atIndex < parseState->stringBuffer.bytes.length)))) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F(parseState->objectStack.index > (parseState->objectStack.count - 4UL))) { if(jk_objectStack_resize(&parseState->objectStack, parseState->objectStack.count + 128UL)) { jk_error(parseState, @\"Internal error: [dictionary] objectsIndex > %zu, resize failed? %@ line #%ld\", (parseState->objectStack.count - 4UL), [NSString stringWithUTF8String:__FILE__], (long)__LINE__); break; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_F((dictState & JKParseAcceptValue)        == 0))    { parseState->errorIsPrev = 1; jk_error(parseState, @\"Unexpected string.\");           stopParsing = 1; break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_F((key = jk_object_for_token(parseState)) == NULL)) {                              jk_error(parseState, @\"Internal error: Key == NULL.\"); stopParsing = 1; break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(JK_EXPECT_T(parseState->token.value.cacheItem != NULL)) { if(JK_EXPECT_F(parseState->token.value.cacheItem->cfHash == 0UL)) { parseState->token.value.cacheItem->cfHash = CFHash(key); } parseState->objectStack.cfHashes[objectStackIndex] = parseState->token.value.cacheItem->cfHash; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        case JKTokenTypeObjectEnd: if((JK_EXPECT_T(dictState & JKParseAcceptEnd)))   { NSCParameterAssert(parseState->objectStack.index >= startingObjectIndex); parsedDictionary = jk_create_dictionary(parseState, startingObjectIndex); } else { parseState->errorIsPrev = 1; jk_error(parseState, @\"Unexpected '}'.\"); } stopParsing = 1; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        case JKTokenTypeComma:     if((JK_EXPECT_T(dictState & JKParseAcceptComma))) { dictState = JKParseAcceptValue; parseState->objectStack.index--; continue; } else { parseState->errorIsPrev = 1; jk_error(parseState, @\"Unexpected ','.\"); stopParsing = 1; } break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        default: parseState->errorIsPrev = 1; jk_error_parse_accept_or3(parseState, dictState, @\"a \\\"STRING\\\"\", @\"a comma\", @\"a '}'\"); stopParsing = 1; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if(JK_EXPECT_T((stopParsing = jk_parse_next_token(parseState)) == 0)) { if(JK_EXPECT_F(parseState->token.type != JKTokenTypeSeparator)) { parseState->errorIsPrev = 1; jk_error(parseState, @\"Expected ':'.\"); stopParsing = 1; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_F((dictState & JKParseAcceptValue)           == 0))    { parseState->errorIsPrev = 1; jk_error(parseState, @\"Unexpected value.\");               stopParsing = 1; break; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_F((object = jk_object_for_token(parseState)) == NULL)) {                              jk_error(parseState, @\"Internal error: Object == NULL.\"); stopParsing = 1; break; } else { parseState->objectStack.objects[objectStackIndex] = object; dictState = JKParseAcceptCommaOrEnd; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        default: parseState->errorIsPrev = 1; jk_error_parse_accept_or3(parseState, dictState, @\"a value\", @\"a comma\", @\"a '}'\"); stopParsing = 1; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F(parsedDictionary == NULL)) { size_t idx = 0UL; for(idx = startingObjectIndex; idx < parseState->objectStack.index; idx++) { if(parseState->objectStack.keys[idx] != NULL) { CFRelease(parseState->objectStack.keys[idx]); parseState->objectStack.keys[idx] = NULL; } if(parseState->objectStack.objects[idx] != NULL) { CFRelease(parseState->objectStack.objects[idx]); parseState->objectStack.objects[idx] = NULL; } } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  else { size_t idx = 0UL; for(idx = startingObjectIndex; idx < parseState->objectStack.index; idx++) { parseState->objectStack.objects[idx] = NULL; parseState->objectStack.keys[idx] = NULL; } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if((parsedObject == NULL) && (JK_AT_STRING_PTR(parseState) == JK_END_STRING_PTR(parseState))) { jk_error(parseState, @\"Reached the end of the buffer.\"); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if((parsedObject != NULL) && ((parseState->parseOptionFlags & JKParseOptionPermitTextAfterValidJSON) == 0) && (JK_AT_STRING_PTR(parseState) < JK_END_STRING_PTR(parseState))) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// This uses a Galois Linear Feedback Shift Register (LFSR) PRNG to pick which item in the cache to age. It has a period of (2^32)-1.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// NOTE: A LFSR *MUST* be initialized to a non-zero value and must always have a non-zero value. The LFSR is initalized to 1 in -initWithParseOptions:",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// The object cache is nothing more than a hash table with open addressing collision resolution that is bounded by JK_CACHE_PROBES attempts.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// The hash table is a linear C array of JKTokenCacheItem.  The terms \"item\" and \"bucket\" are synonymous with the index in to the cache array, i.e. cache.items[bucket].",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// Items in the cache have an age associated with them.  An items age is incremented using saturating unsigned arithmetic and decremeted using unsigned right shifts.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// Thus, an items age is managed using an AIMD policy- additive increase, multiplicative decrease.  All age calculations and manipulations are branchless.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  unsigned long  bucket     = parseState->token.value.hash & (parseState->cache.count - 1UL), setBucket = 0UL, useableBucket = 0UL, x = 0UL;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F(parseState->token.value.ptrRange.length == 0UL) && JK_EXPECT_T(parseState->token.value.type == JKValueTypeString)) { return(@\"\"); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if((JK_EXPECT_T(parseState->cache.items[bucket].hash == parseState->token.value.hash)) && (JK_EXPECT_T(parseState->cache.items[bucket].size == parseState->token.value.ptrRange.length)) && (JK_EXPECT_T(parseState->cache.items[bucket].type == parseState->token.value.type)) && (JK_EXPECT_T(parseState->cache.items[bucket].bytes != NULL)) && (JK_EXPECT_T(memcmp(parseState->cache.items[bucket].bytes, parseState->token.value.ptrRange.ptr, parseState->token.value.ptrRange.length) == 0U))) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      parseState->cache.age[bucket]     = (((uint32_t)parseState->cache.age[bucket]) + 1U) - (((((uint32_t)parseState->cache.age[bucket]) + 1U) >> 31) ^ 1U);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if(JK_EXPECT_F(setBucket == 0UL) && JK_EXPECT_F(parseState->cache.age[bucket] == 0U)) { setBucket = 1UL; useableBucket = bucket; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if(JK_EXPECT_F(setBucket == 0UL))                                                     { parseState->cache.age[bucket] >>= 1; jk_cache_age(parseState); jk_cache_age(parseState); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      // This is the open addressing function.  The values length and type are used as a form of \"double hashing\" to distribute values with the same effective value hash across different object cache buckets.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      // The values type is a prime number that is relatively coprime to the other primes in the set of value types and the number of hash table buckets.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      bucket = (parseState->token.value.hash + (parseState->token.value.ptrRange.length * (x + 1UL)) + (parseState->token.value.type * (x + 1UL)) + (3UL * (x + 1UL))) & (parseState->cache.count - 1UL);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    case JKValueTypeString:           parsedAtom = (void *)CFStringCreateWithBytes(NULL, parseState->token.value.ptrRange.ptr, parseState->token.value.ptrRange.length, kCFStringEncodingUTF8, 0); break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    case JKValueTypeLongLong:         parsedAtom = (void *)CFNumberCreate(NULL, kCFNumberLongLongType, &parseState->token.value.number.longLongValue);                                             break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if(parseState->token.value.number.unsignedLongLongValue <= LLONG_MAX) { parsedAtom = (void *)CFNumberCreate(NULL, kCFNumberLongLongType, &parseState->token.value.number.unsignedLongLongValue); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      else { parsedAtom = (void *)parseState->objCImpCache.NSNumberInitWithUnsignedLongLong(parseState->objCImpCache.NSNumberAlloc(parseState->objCImpCache.NSNumberClass, @selector(alloc)), @selector(initWithUnsignedLongLong:), parseState->token.value.number.unsignedLongLongValue); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    case JKValueTypeDouble:           parsedAtom = (void *)CFNumberCreate(NULL, kCFNumberDoubleType,   &parseState->token.value.number.doubleValue);                                               break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    default: jk_error(parseState, @\"Internal error: Unknown token value type. %@ line #%ld\", [NSString stringWithUTF8String:__FILE__], (long)__LINE__); break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_T((parseState->cache.items[bucket].object != NULL))) { CFRelease(parseState->cache.items[bucket].object); parseState->cache.items[bucket].object = NULL; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_T((parseState->cache.items[bucket].bytes = (unsigned char *)reallocf(parseState->cache.items[bucket].bytes, parseState->token.value.ptrRange.length)) != NULL)) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    default: jk_error(parseState, @\"Internal error: Unknown token type. %@ line #%ld\", [NSString stringWithUTF8String:__FILE__], (long)__LINE__); break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(parseOptionFlags & ~JKParseOptionValidFlags) { [self autorelease]; [NSException raise:NSInvalidArgumentException format:@\"Invalid parse options.\"]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if((parseState->cache.items = (JKTokenCacheItem *)calloc(1UL, sizeof(JKTokenCacheItem) * parseState->cache.count)) == NULL) { goto errorExit; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// This is here primarily to support the NSString and NSData convenience functions so the autoreleased JSONDecoder can release most of its resources before the pool pops.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(decoder->parseState->cache.items != NULL) { free(decoder->parseState->cache.items); decoder->parseState->cache.items = NULL; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        if(JK_EXPECT_T(parseState->cache.items[idx].object != NULL)) { CFRelease(parseState->cache.items[idx].object); parseState->cache.items[idx].object = NULL; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        if(JK_EXPECT_T(parseState->cache.items[idx].bytes  != NULL)) { free(parseState->cache.items[idx].bytes);       parseState->cache.items[idx].bytes  = NULL; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static id _JKParseUTF8String(JKParseState *parseState, BOOL mutableCollections, const unsigned char *string, size_t length, NSError **error) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":" In the simpler v1.3 code, this included all the bytes used to store the -UTF8String along with the JSONDecoder and all its overhead.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static id _NSStringObjectFromJSONString(NSString *jsonString, JKParseOptionFlags parseOptionFlags, NSError **error, BOOL mutableCollection) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    convertedCount = CFStringGetBytes((CFStringRef)jsonString, CFRangeMake(0L, stringLength), kCFStringEncodingUTF8, '?', NO, utf8String, (NSUInteger)stringUTF8Length, &usedBytes);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F(convertedCount != stringLength) || JK_EXPECT_F(usedBytes < 0L)) { if(error != NULL) { *error = [NSError errorWithDomain:@\"JKErrorDomain\" code:-1L userInfo:[NSDictionary dictionaryWithObject:@\"An error occurred converting the contents of a NSString to UTF8.\" forKey:NSLocalizedDescriptionKey]]; } goto exitNow; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(mutableCollection == NO) { returnObject = [(decoder = [JSONDecoder decoderWithParseOptions:parseOptionFlags])        objectWithUTF8String:(const unsigned char *)utf8String length:(size_t)usedBytes error:error]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else                        { returnObject = [(decoder = [JSONDecoder decoderWithParseOptions:parseOptionFlags]) mutableObjectWithUTF8String:(const unsigned char *)utf8String length:(size_t)usedBytes error:error]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"JK_STATIC_INLINE void jk_encode_updateCache(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static int jk_encode_printf(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format, ...) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((encodeState != NULL) && (encodeState->atIndex < encodeState->stringBuffer.bytes.length) && (startingAtIndex <= encodeState->atIndex) && (format != NULL));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_T((formattedStringLength = vsnprintf((char *)&encodeState->stringBuffer.bytes.ptr[encodeState->atIndex], (encodeState->stringBuffer.bytes.length - encodeState->atIndex), format, varArgsList)) >= (ssize_t)(encodeState->stringBuffer.bytes.length - encodeState->atIndex))) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F(((encodeState->atIndex + (formattedStringLength * 2UL) + 256UL) > encodeState->stringBuffer.bytes.length)) && JK_EXPECT_F((jk_managedBuffer_resize(&encodeState->stringBuffer, encodeState->atIndex + (formattedStringLength * 2UL)+ 4096UL) == NULL))) { jk_encode_error(encodeState, @\"Unable to resize temporary buffer.\"); returnValue = 1; goto exitNow; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F((formattedStringLength = vsnprintf((char *)&encodeState->stringBuffer.bytes.ptr[encodeState->atIndex], (encodeState->stringBuffer.bytes.length - encodeState->atIndex), format, varArgsListCopy)) >= (ssize_t)(encodeState->stringBuffer.bytes.length - encodeState->atIndex))) { jk_encode_error(encodeState, @\"vsnprintf failed unexpectedly.\"); returnValue = 1; goto exitNow; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_T(returnValue == 0)) { encodeState->atIndex += formattedStringLength; jk_encode_updateCache(encodeState, cacheSlot, startingAtIndex, object); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static int jk_encode_write(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((encodeState != NULL) && (encodeState->atIndex < encodeState->stringBuffer.bytes.length) && (startingAtIndex <= encodeState->atIndex) && (format != NULL));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F(((encodeState->atIndex + strlen(format) + 256UL) > encodeState->stringBuffer.bytes.length)) && JK_EXPECT_F((jk_managedBuffer_resize(&encodeState->stringBuffer, encodeState->atIndex + strlen(format) + 1024UL) == NULL))) { jk_encode_error(encodeState, @\"Unable to resize temporary buffer.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  for(formatIdx = 0UL; format[formatIdx] != 0; formatIdx++) { NSCParameterAssert(encodeState->atIndex < encodeState->stringBuffer.bytes.length); encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = format[formatIdx]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F((encodeState->atIndex + ((encodeState->depth + 1UL) * 2UL) + 16UL) > encodeState->stringBuffer.bytes.length) && JK_EXPECT_T(jk_managedBuffer_resize(&encodeState->stringBuffer, encodeState->atIndex + ((encodeState->depth + 1UL) * 2UL) + 4096UL) == NULL)) { jk_encode_error(encodeState, @\"Unable to resize temporary buffer.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  for(depthWhiteSpace = 0UL; depthWhiteSpace < (encodeState->depth * 2UL); depthWhiteSpace++) { NSCParameterAssert(encodeState->atIndex < encodeState->stringBuffer.bytes.length); encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = ' '; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((encodeState != NULL) && (encodeState->atIndex < encodeState->stringBuffer.bytes.length) && (format != NULL) && ((depthChange >= -1L) && (depthChange <= 1L)) && ((encodeState->depth == 0UL) ? (depthChange >= 0L) : 1) && ((encodeState->serializeOptionFlags & JKSerializeOptionPretty) != 0UL));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F((encodeState->atIndex + ((encodeState->depth + 1UL) * 2UL) + 16UL) > encodeState->stringBuffer.bytes.length) && JK_EXPECT_F(jk_managedBuffer_resize(&encodeState->stringBuffer, encodeState->atIndex + ((encodeState->depth + 1UL) * 2UL) + 4096UL) == NULL)) { jk_encode_error(encodeState, @\"Unable to resize temporary buffer.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_T(format[0] == ':')) { encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = format[0]; encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = ' '; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((encodeState != NULL) && (encodeState->atIndex < encodeState->stringBuffer.bytes.length) && ((encodeState->serializeOptionFlags & JKSerializeOptionPretty) == 0UL));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_T((encodeState->atIndex + 4UL) < encodeState->stringBuffer.bytes.length)) { encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = format[0]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"static int jk_encode_writen(JKEncodeState *encodeState, JKEncodeCache *cacheSlot, size_t startingAtIndex, id object, const char *format, size_t length) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((encodeState != NULL) && (encodeState->atIndex < encodeState->stringBuffer.bytes.length) && (startingAtIndex <= encodeState->atIndex));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(JK_EXPECT_F((encodeState->stringBuffer.bytes.length - encodeState->atIndex) < (length + 4UL))) { if(jk_managedBuffer_resize(&encodeState->stringBuffer, encodeState->atIndex + 4096UL + length) == NULL) { jk_encode_error(encodeState, @\"Unable to resize temporary buffer.\"); return(1); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSCParameterAssert((encodeState != NULL) && (encodeState->atIndex < encodeState->stringBuffer.bytes.length) && (objectPtr != NULL));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                       (cacheSlot->offset < encodeState->atIndex)                   && ((cacheSlot->offset + cacheSlot->length) < encodeState->atIndex)                                    &&",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                       (cacheSlot->offset < encodeState->stringBuffer.bytes.length) && ((cacheSlot->offset + cacheSlot->length) < encodeState->stringBuffer.bytes.length)                  &&",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                       ((encodeState->stringBuffer.bytes.ptr + encodeState->atIndex)                     < (encodeState->stringBuffer.bytes.ptr + encodeState->stringBuffer.bytes.length)) &&",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                       ((encodeState->stringBuffer.bytes.ptr + cacheSlot->offset)                        < (encodeState->stringBuffer.bytes.ptr + encodeState->stringBuffer.bytes.length)) &&",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                       ((encodeState->stringBuffer.bytes.ptr + cacheSlot->offset + cacheSlot->length)    < (encodeState->stringBuffer.bytes.ptr + encodeState->stringBuffer.bytes.length)));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(JK_EXPECT_F(((encodeState->atIndex + cacheSlot->length + 256UL) > encodeState->stringBuffer.bytes.length)) && JK_EXPECT_F((jk_managedBuffer_resize(&encodeState->stringBuffer, encodeState->atIndex + cacheSlot->length + 1024UL) == NULL))) { jk_encode_error(encodeState, @\"Unable to resize temporary buffer.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                       ((encodeState->stringBuffer.bytes.ptr + encodeState->atIndex)                     < (encodeState->stringBuffer.bytes.ptr + encodeState->stringBuffer.bytes.length)) &&",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                       ((encodeState->stringBuffer.bytes.ptr + encodeState->atIndex + cacheSlot->length) < (encodeState->stringBuffer.bytes.ptr + encodeState->stringBuffer.bytes.length)) &&",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                       ((encodeState->stringBuffer.bytes.ptr + cacheSlot->offset)                        < (encodeState->stringBuffer.bytes.ptr + encodeState->stringBuffer.bytes.length)) &&",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                       ((encodeState->stringBuffer.bytes.ptr + cacheSlot->offset + cacheSlot->length)    < (encodeState->stringBuffer.bytes.ptr + encodeState->stringBuffer.bytes.length)) &&",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                       ((encodeState->stringBuffer.bytes.ptr + cacheSlot->offset + cacheSlot->length)    < (encodeState->stringBuffer.bytes.ptr + encodeState->atIndex)));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    memcpy(encodeState->stringBuffer.bytes.ptr + encodeState->atIndex, encodeState->stringBuffer.bytes.ptr + cacheSlot->offset, cacheSlot->length);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  // When we encounter a class that we do not handle, and we have either a delegate or block that the user supplied to format unsupported classes,",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  // we \"re-run\" the object check.  However, we re-run the object check exactly ONCE.  If the user supplies an object that isn't one of the",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     We need to work around a bug in 10.7, which breaks ABI compatibility with Objective-C going back not just to 10.0, but OpenStep and even NextStep.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     It has long been documented that \"the very first thing that a pointer to an Objective-C object \"points to\" is a pointer to that objects class\".",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     This is euphemistically called \"tagged pointers\".  There are a number of highly technical problems with this, most involving long passages from",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     the C standard(s).  In short, one can make a strong case, couched from the perspective of the C standard(s), that that 10.7 \"tagged pointers\" are",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     fundamentally Wrong and Broken, and should have never been implemented.  Assuming those points are glossed over, because the change is very clearly",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     breaking ABI compatibility, this should have resulted in a minimum of a \"minimum version required\" bump in various shared libraries to prevent",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     In fact, the C standard says that the hack below is \"undefined behavior\"- there is no requirement that the 10.7 tagged pointer hack of setting the",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     \"lower, unused bits\" must be preserved when casting the result to an integer type, but this \"works\" because for most architectures",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     `sizeof(long) == sizeof(void *)` and the compiler uses the same representation for both.  (note: this is informal, not meant to be",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     In other words, while this \"works\" for now, technically the compiler is not obligated to do \"what we want\", and a later version of the compiler",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     is not required in any way to produce the same results or behavior that earlier versions of the compiler did for the statement below.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     Why not just use `object_getClass()`?  Because `object->isa` reduces to (typically) a *single* instruction.  Calling `object_getClass()` requires",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     that the compiler potentially spill registers, establish a function call frame / environment, and finally execute a \"jump subroutine\" instruction.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     Then, the called subroutine must spend half a dozen instructions in its prolog, however many instructions doing whatever it does, then half a dozen",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  //     Yes, that's one to two orders of magnitude difference.  Which is compelling in its own right.  When going for performance, you're often happy with",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"         if(JK_EXPECT_T([object isKindOfClass:[NSString     class]])) { if(workAroundMacOSXABIBreakingBug == NO) { encodeState->fastClassLookup.stringClass     = objectISA; } isClass = JKClassString;     }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T([object isKindOfClass:[NSNumber     class]])) { if(workAroundMacOSXABIBreakingBug == NO) { encodeState->fastClassLookup.numberClass     = objectISA; } isClass = JKClassNumber;     }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T([object isKindOfClass:[NSDictionary class]])) { if(workAroundMacOSXABIBreakingBug == NO) { encodeState->fastClassLookup.dictionaryClass = objectISA; } isClass = JKClassDictionary; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T([object isKindOfClass:[NSArray      class]])) { if(workAroundMacOSXABIBreakingBug == NO) { encodeState->fastClassLookup.arrayClass      = objectISA; } isClass = JKClassArray;      }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    else if(JK_EXPECT_T([object isKindOfClass:[NSNull       class]])) { if(workAroundMacOSXABIBreakingBug == NO) { encodeState->fastClassLookup.nullClass       = objectISA; } isClass = JKClassNull;       }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"           ((encodeState->classFormatterBlock) && ((object = encodeState->classFormatterBlock(object))                                                                         != NULL)) ||",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"           ((encodeState->classFormatterIMP)   && ((object = encodeState->classFormatterIMP(encodeState->classFormatterDelegate, encodeState->classFormatterSelector, object)) != NULL))    )) { rerunningAfterClassFormatter = YES; goto rerunAfterClassFormatter; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      if(rerunningAfterClassFormatter == NO) { jk_encode_error(encodeState, @\"Unable to serialize object class %@.\", NSStringFromClass([encodeCacheObject class])); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"      else { jk_encode_error(encodeState, @\"Unable to serialize object class %@ that was returned by the unsupported class formatter.  Original object class was %@.\", (object == NULL) ? @\"NULL\" : NSStringFromClass([object class]), NSStringFromClass([encodeCacheObject class])); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  // #define jk_encode_write1(es, dc, f) (_jk_encode_prettyPrint ? jk_encode_write1slow(es, dc, f) : jk_encode_write1fast(es, dc, f))",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          const unsigned char *cStringPtr = (const unsigned char *)CFStringGetCStringPtr((CFStringRef)object, kCFStringEncodingMacRoman);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(JK_EXPECT_F(((encodeState->atIndex + (stringLength * 2UL) + 256UL) > encodeState->stringBuffer.bytes.length)) && JK_EXPECT_F((jk_managedBuffer_resize(&encodeState->stringBuffer, encodeState->atIndex + (stringLength * 2UL) + 1024UL) == NULL))) { jk_encode_error(encodeState, @\"Unable to resize temporary buffer.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(JK_EXPECT_T((encodeState->encodeOption & JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\"'; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"              NSCParameterAssert(((&encodeState->stringBuffer.bytes.ptr[encodeState->atIndex]) - encodeState->stringBuffer.bytes.ptr) < (ssize_t)encodeState->stringBuffer.bytes.length);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                  case '\\b': encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = 'b'; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                  case '\\f': encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = 'f'; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                  case '\\n': encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = 'n'; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                  case '\\r': encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = 'r'; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                  case '\\t': encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = 't'; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                  default: if(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, \"\\\\u%4.4x\", utf8String[utf8Idx]))) { return(1); } break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                if(JK_EXPECT_F(utf8String[utf8Idx] == '\\\"') || JK_EXPECT_F(utf8String[utf8Idx] == '\\\\') || (JK_EXPECT_F(encodeState->serializeOptionFlags & JKSerializeOptionEscapeForwardSlashes) && JK_EXPECT_F(utf8String[utf8Idx] == '/'))) { encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(JK_EXPECT_T((encodeState->encodeOption & JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\"'; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_F((size_t)maxStringUTF8Length > encodeState->utf8ConversionBuffer.bytes.length) && JK_EXPECT_F(jk_managedBuffer_resize(&encodeState->utf8ConversionBuffer, maxStringUTF8Length + 1024UL) == NULL)) { jk_encode_error(encodeState, @\"Unable to resize temporary buffer.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          convertedCount = CFStringGetBytes((CFStringRef)object, CFRangeMake(0L, stringLength), kCFStringEncodingUTF8, '?', NO, encodeState->utf8ConversionBuffer.bytes.ptr, encodeState->utf8ConversionBuffer.bytes.length - 16L, &usedBytes);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_F(convertedCount != stringLength) || JK_EXPECT_F(usedBytes < 0L)) { jk_encode_error(encodeState, @\"An error occurred converting the contents of a NSString to UTF8.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_F((encodeState->atIndex + (maxStringUTF8Length * 2UL) + 256UL) > encodeState->stringBuffer.bytes.length) && JK_EXPECT_F(jk_managedBuffer_resize(&encodeState->stringBuffer, encodeState->atIndex + (maxStringUTF8Length * 2UL) + 1024UL) == NULL)) { jk_encode_error(encodeState, @\"Unable to resize temporary buffer.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_T((encodeState->encodeOption & JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\"'; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            NSCParameterAssert(((&encodeState->stringBuffer.bytes.ptr[encodeState->atIndex]) - encodeState->stringBuffer.bytes.ptr) < (ssize_t)encodeState->stringBuffer.bytes.length);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                case '\\b': encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = 'b'; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                case '\\f': encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = 'f'; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                case '\\n': encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = 'n'; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                case '\\r': encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = 'r'; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                case '\\t': encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = 't'; break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                default: if(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, \"\\\\u%4.4x\", utf8String[utf8Idx]))) { return(1); } break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"              if(JK_EXPECT_F(utf8String[utf8Idx] >= 0x80U) && (encodeState->serializeOptionFlags & JKSerializeOptionEscapeUnicode)) {",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                if(JK_EXPECT_F((result = ConvertSingleCodePointInUTF8(&utf8String[utf8Idx], &utf8String[usedBytes], (UTF8 const **)&nextValidCharacter, &u32ch)) != conversionOK)) { jk_encode_error(encodeState, @\"Error converting UTF8.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                  if(JK_EXPECT_T(u32ch <= 0xffffU)) { if(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, \"\\\\u%4.4x\", u32ch)))                                                           { return(1); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                  else                              { if(JK_EXPECT_F(jk_encode_printf(encodeState, NULL, 0UL, NULL, \"\\\\u%4.4x\\\\u%4.4x\", (0xd7c0U + (u32ch >> 10)), (0xdc00U + (u32ch & 0x3ffU))))) { return(1); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                if(JK_EXPECT_F(utf8String[utf8Idx] == '\\\"') || JK_EXPECT_F(utf8String[utf8Idx] == '\\\\') || (JK_EXPECT_F(encodeState->serializeOptionFlags & JKSerializeOptionEscapeForwardSlashes) && JK_EXPECT_F(utf8String[utf8Idx] == '/'))) { encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\\'; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          if(JK_EXPECT_T((encodeState->encodeOption & JKEncodeOptionStringObjTrimQuotes) == 0UL)) { encodeState->stringBuffer.bytes.ptr[encodeState->atIndex++] = '\\\"'; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"             if(object == (id)kCFBooleanTrue)  { return(jk_encode_writen(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, \"true\",  4UL)); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        else if(object == (id)kCFBooleanFalse) { return(jk_encode_writen(encodeState, cacheSlot, startingAtIndex, encodeCacheObject, \"false\", 5UL)); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        if(JK_EXPECT_F(objCType == NULL) || JK_EXPECT_F(objCType[0] == 0) || JK_EXPECT_F(objCType[1] != 0)) { jk_encode_error(encodeState, @\"NSNumber conversion error, unknown type.  Type: '%s'\", (objCType == NULL) ? \"<NULL>\" : objCType); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"              if(JK_EXPECT_F(ullv < 10ULL)) { *--aptr = ullv + '0'; } else { while(JK_EXPECT_T(ullv > 0ULL)) { *--aptr = (ullv % 10ULL) + '0'; ullv /= 10ULL; NSCParameterAssert(aptr > anum); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                if(JK_EXPECT_F(!isfinite(dv))) { jk_encode_error(encodeState, @\"Floating point values must be finite.  JSON does not support NaN or Infinity.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          default: jk_encode_error(encodeState, @\"NSNumber conversion error, unknown type.  Type: '%c' / 0x%2.2x\", objCType[0], objCType[0]); return(1); break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          for(id arrayObject in object)          { if(JK_EXPECT_T(printComma)) { if(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, \",\"))) { return(1); } } printComma = 1; if(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, arrayObject)))  { return(1); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"          for(idx = 0L; idx < arrayCount; idx++) { if(JK_EXPECT_T(printComma)) { if(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, \",\"))) { return(1); } } printComma = 1; if(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, objects[idx]))) { return(1); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        id      enumerateObject = JK_EXPECT_F(_jk_encode_prettyPrint) ? [[object allKeys] sortedArrayUsingSelector:@selector(compare:)] : object;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(JK_EXPECT_F((keyObjectISA != encodeState->fastClassLookup.stringClass)) && JK_EXPECT_F(([keyObject isKindOfClass:[NSString class]] == NO))) { jk_encode_error(encodeState, @\"Key must be a string object.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, keyObject)))                                                        { return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(JK_EXPECT_F(jk_encode_write1(encodeState, 0L, \":\")))                                                                      { return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(JK_EXPECT_F(jk_encode_add_atom_to_buffer(encodeState, (void *)CFDictionaryGetValue((CFDictionaryRef)object, keyObject)))) { return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"            if(JK_EXPECT_F(keyObjectISA != encodeState->fastClassLookup.stringClass) && JK_EXPECT_F([(id)keys[idx] isKindOfClass:[NSString class]] == NO)) { jk_encode_error(encodeState, @\"Key must be a string object.\"); return(1); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    default: jk_encode_error(encodeState, @\"Unable to serialize object class %@.\", NSStringFromClass([object class])); return(1); break;",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"+ (id)serializeObject:(id)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(id)delegate selector:(SEL)selector error:(NSError **)error",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([[[[self alloc] init] autorelease] serializeObject:object options:optionFlags encodeOption:encodeOption block:block delegate:delegate selector:selector error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"- (id)serializeObject:(id)object options:(JKSerializeOptionFlags)optionFlags encodeOption:(JKEncodeOptionType)encodeOption block:(JKSERIALIZER_BLOCKS_PROTO)block delegate:(id)delegate selector:(SEL)selector error:(NSError **)error",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  NSParameterAssert((object != NULL) && (encodeState == NULL) && ((delegate != NULL) ? (block == NULL) : 1) && ((block != NULL) ? (delegate == NULL) : 1) &&",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                    (((encodeOption & JKEncodeOptionCollectionObj) != 0UL) ? (((encodeOption & JKEncodeOptionStringObj)     == 0UL) && ((encodeOption & JKEncodeOptionStringObjTrimQuotes) == 0UL)) : 1) &&",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"                    (((encodeOption & JKEncodeOptionStringObj)     != 0UL) ?  ((encodeOption & JKEncodeOptionCollectionObj) == 0UL)                                                                 : 1));",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if((encodeState = (struct JKEncodeState *)calloc(1UL, sizeof(JKEncodeState))) == NULL) { [NSException raise:NSMallocException format:@\"Unable to allocate state structure.\"]; return(NULL); }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if(selector                               == NULL) { [NSException raise:NSInvalidArgumentException format:@\"The delegate argument is not NULL, but the selector argument is NULL.\"]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if([delegate respondsToSelector:selector] == NO)   { [NSException raise:NSInvalidArgumentException format:@\"The serializeUnsupportedClassesUsingDelegate: delegate does not respond to the selector argument.\"]; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(((encodeOption & JKEncodeOptionCollectionObj) != 0UL) && (([object isKindOfClass:[NSArray  class]] == NO) && ([object isKindOfClass:[NSDictionary class]] == NO))) { jk_encode_error(encodeState, @\"Unable to serialize object class %@, expected a NSArray or NSDictionary.\", NSStringFromClass([object class])); goto errorExit; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if(((encodeOption & JKEncodeOptionStringObj)     != 0UL) &&  ([object isKindOfClass:[NSString class]] == NO))                                                         { jk_encode_error(encodeState, @\"Unable to serialize object class %@, expected a NSString.\", NSStringFromClass([object class])); goto errorExit; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if((stackBuffer == NO) && ((encodeState->stringBuffer.bytes.ptr = (unsigned char *)reallocf(encodeState->stringBuffer.bytes.ptr, encodeState->atIndex + 16UL)) == NULL)) { jk_encode_error(encodeState, @\"Unable to realloc buffer\"); goto errorExit; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        if(stackBuffer == YES) { if((returnObject = [(id)CFDataCreate(                 NULL,                encodeState->stringBuffer.bytes.ptr, (CFIndex)encodeState->atIndex)                                  autorelease]) == NULL) { jk_encode_error(encodeState, @\"Unable to create NSData object\"); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        else                   { if((returnObject = [(id)CFDataCreateWithBytesNoCopy(  NULL,                encodeState->stringBuffer.bytes.ptr, (CFIndex)encodeState->atIndex, NULL)                            autorelease]) == NULL) { jk_encode_error(encodeState, @\"Unable to create NSData object\"); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        if(stackBuffer == YES) { if((returnObject = [(id)CFStringCreateWithBytes(      NULL, (const UInt8 *)encodeState->stringBuffer.bytes.ptr, (CFIndex)encodeState->atIndex, kCFStringEncodingUTF8, NO)       autorelease]) == NULL) { jk_encode_error(encodeState, @\"Unable to create NSString object\"); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"        else                   { if((returnObject = [(id)CFStringCreateWithBytesNoCopy(NULL, (const UInt8 *)encodeState->stringBuffer.bytes.ptr, (CFIndex)encodeState->atIndex, kCFStringEncodingUTF8, NO, NULL) autorelease]) == NULL) { jk_encode_error(encodeState, @\"Unable to create NSString object\"); } }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"    if((returnObject != NULL) && (stackBuffer == NO)) { encodeState->stringBuffer.flags &= ~JKManagedBufferMustFree; encodeState->stringBuffer.bytes.ptr = NULL; encodeState->stringBuffer.bytes.length = 0UL; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  if((encodeState != NULL) && (error != NULL) && (encodeState->error != NULL)) { *error = encodeState->error; encodeState->error = NULL; }",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"// Useful for those who need to serialize just a NSString.  Otherwise you would have to do something like [NSArray arrayWithObject:stringToBeJSONSerialized], serializing the array, and then chopping of the extra ^\\[.*\\]$ square brackets.",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | ((includeQuotes == NO) ? JKEncodeOptionStringObjTrimQuotes : 0UL) | JKEncodeOptionStringObj) block:NULL delegate:NULL selector:NULL error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions includeQuotes:(BOOL)includeQuotes error:(NSError **)error",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | ((includeQuotes == NO) ? JKEncodeOptionStringObjTrimQuotes : 0UL) | JKEncodeOptionStringObj) block:NULL delegate:NULL selector:NULL error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"- (NSData *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(id)delegate selector:(SEL)selector error:(NSError **)error",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(id)delegate selector:(SEL)selector error:(NSError **)error",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"- (NSData *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(id)delegate selector:(SEL)selector error:(NSError **)error",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:JKSerializeOptionNone encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:NULL]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:NULL selector:NULL error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingDelegate:(id)delegate selector:(SEL)selector error:(NSError **)error",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:NULL delegate:delegate selector:selector error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"- (NSData *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(id(^)(id object))block error:(NSError **)error",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(id(^)(id object))block error:(NSError **)error",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"- (NSData *)JSONDataWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(id(^)(id object))block error:(NSError **)error",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsData | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"- (NSString *)JSONStringWithOptions:(JKSerializeOptionFlags)serializeOptions serializeUnsupportedClassesUsingBlock:(id(^)(id object))block error:(NSError **)error",
        "WIDTH":132
    },
    {
        "TYPE":"LENGTH",
        "LONG":"  return([JKSerializer serializeObject:self options:serializeOptions encodeOption:(JKEncodeOptionAsString | JKEncodeOptionCollectionObj) block:block delegate:NULL selector:NULL error:error]);",
        "WIDTH":132
    }
]
